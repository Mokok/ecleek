grammar org.processus.ecleek.Leek with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate leek "http://www.processus.org/ecleek/Leek"

Script:
	statements+=Statement*;

Statement:
	Include ';'
	| GlobalDeclaration ';'
	| FunctionDeclaration
	| LocalDeclaration ';'
	| FunctionCall ';'
	| Iteration
	| If
	| AffectationStatement ';'
	| StatementBlock
	| ReturnStatement ';'
	| BreakStatement ';'
	| ContinueStatement ';'
//	| Postfix ';'
	| {EmptyStatement} ';'
;

BreakStatement:
	{BreakStatement} 'break'
;

ContinueStatement:
	{ContinueStatement} 'continue'
;

StatementBlock:
	'{' {StatementBlock} statements+=Statement* '}'
;

AffectationStatement:
	=> AffectationDecrement
	| =>  AffectationIncrement
	| Affectation
;

Affectation:
	variable=VariableReference '=' value=Expression
;

AffectationDecrement:
	variable=VariableReference '-=' decrement=Expression
;

AffectationIncrement:
	variable=VariableReference '+=' increment=Expression
;

If:
	'if' '(' condition=Expression ')' then=Statement (=> 'else' else=Statement)?
;

Iteration:
	While
	| ForIn
	| For
;

While:
	'while' '(' condition=Expression ')' statement=Statement
;

For:
	'for' '(' initializer=ForInitializer ';' condition=Expression ';' increment=Expression ')' statement=Statement
;

ForIn:
	'for' '(' (key=ForInVariableReference ':')? value=ForInVariableReference 'in' array=Expression ')' statement=Statement
;

ForInVariableReference:
	'var' VariableDeclarationUnitialized
	| VariableReferenceSimple
;

ForInitializer:
	'var' VariableDeclarationWithValue
	| Affectation
;

FunctionDeclaration:
	'function' name=ID '(' (parameters+=ParameterDeclaration (',' parameters+=ParameterDeclaration)*)? ')' body=StatementBlock
;

ParameterDeclaration returns VariableReference:
	(byAdress?='@')? name=ID
;

LocalDeclaration:
	'var' variables+=VariableDeclaration (',' variables+=VariableDeclaration)*
;

GlobalDeclaration:
	'global' variables+=VariableDeclaration (',' variables+=VariableDeclaration)*
;

VariableDeclaration returns VariableReference:
	VariableDeclarationWithValue
	| VariableDeclarationUnitialized
;

VariableDeclarationWithValue returns VariableReference:
	name=ID '=' value=Expression
;

VariableDeclarationUnitialized returns VariableReference:
	name=ID
;

Expression:
	Comparison;

Comparison returns Expression:
	Or (({Comparison.left=current} '===' | {Equals.left=current} '==' | {TypedDifferent.left=current} '!==' | {Different.left=current} '!=' | {LessOrEquals.left=current} '<=' | {Less.left=current} '<' | {MoreOrEquals.left=current} '>=' | {More.left=current} '>') right=Or)*;

Or returns Expression:
	And (({Or.left=current} ('or'|'||')) right=And)*;

And returns Expression:
	Addition (({And.left=current} ('and'|'&&')) right=Addition)*;

Addition returns Expression:
	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*;

Multiplication returns Expression:
	PrimaryExpression (({Multi.left=current} '*' | {Div.left=current} '/') right=PrimaryExpression)*;

PrimaryExpression returns Expression:
	'(' Expression ')'
	| {UnitaryMinus} '-' expression=PrimaryExpression
	| {RealLiteral} value=REAL
	| {IntLiteral} value=INT
	| FunctionCall
	| Postfix
	| {StringLiteral} value=STRING
	| ArrayLiteral
	| FunctionDeclaration
	| {NullLiteral} 'null'
	| {FalseLiteral} 'false'
	| {TrueLiteral} 'true'
;

ArrayLiteral:
	{ArrayLiteral} '[' (values+=Expression (',' values+=Expression)*)? ']'
;

VariableReference:
	=> VariableReferenceArray
	| VariableReferenceSimple
;

Postfix:
	VariableReference (({PostfixDecrement.value=current} '--' | {PostfixIncrement.value=current} '++'))?
;

VariableReferenceSimple returns VariableReference:
	variable=[VariableReference]
;

VariableReferenceArray returns VariableReference:
	variable=[VariableReference] ('[' dimensions+=Expression ']')+
;

FunctionCall:
	{FunctionCall} function=[FunctionDeclaration] '(' (args+=Expression (',' args+=Expression)*)? ')'
;

ReturnStatement:
	'return' value=Expression
;

Include:
	'include' '(' importURI=STRING ')'
;

terminal REAL returns ecore::EDouble:
	('0'..'9')* '.' ('0'..'9')+
;
